<html>
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href=/static/css/main.css rel="stylesheet" type="text/css">
        <title>neox2</title>
    </head>
    <body>
        <h1>《操作系统真相还原》第二章小结</h1>
<h2>计算机的启动过程</h2>
<h3>以前的文章</h3>
<p>我去年寒假(很久以前...)写过一篇博客:《计算机是如何启动的》, 我说到了计算机启动的大致过程</p>
<p>```
let's BOOTstrap ! |||||||||||||||||||||||||||!!!!!!!!!!!!!</p>
<p>计算机的启动(BOOT)就是很自然的把以上概念串联起来的过程。在BOOT的过程中需要注意顺序和控制权这两个概念。
第一阶段: BIOS</p>
<p>控制权: BIOS
计算机接通电源后, 读取固化(比如烧录)到ROM芯片上的BIOS程序。首先计算机会进行硬件带电自检, 如果硬件出现问题, 启动终止, 主板发出蜂鸣;如果一切正常, 屏幕上会显示CPU,内存信息。
初始化和检测完成后, BIOS需要把控制权交给下一阶段启动程序,这可以在BIOS启动顺序列表中设置, 比如安装ubuntu时设置先从U盘启动。</p>
<p>第二阶段: MBR</p>
<p>控制权: 优先启动的存储设备
这时计算机读取该设备第一个扇区的512个字节, 如果最后两个字节是0x55和0xAA, 则可以启动。如果不是, 则将控制权转给BIOS启动顺序列表中的下一个启动设备。</p>
<p>第三阶段: 硬盘启动</p>
<p>控制权: 硬盘中的某个分区
这里又分三种情况:</p>
<p>读取激活分区的第一个扇区(卷引导纪录), 加载操作系统
扩展分区和逻辑分区
硬盘有4个主分区
有且仅有一个区可以定义为扩展分区
扩展分区中又可以划分若干逻辑分区
计算机首先会读取扩展分区的第一个扇区(扩展引导纪录), 然后读取第二个逻辑分区的第一个扇区,在从里面的分区表中读取第三个逻辑分区的位置, 依次进行下去。
控制权: 启动管理器
直接将控制权交给事先安装的启动管理器, 由用户选择启动的操作系统
第四阶段: 操作系统</p>
<p>控制权: 操作系统
操作系统的内核会被首先载入内存, 然后执行操作系统规划好的程序, 启动完成。
```</p>
<h3>更细致的理解</h3>
<p>通过阅读《操作系统真相还原》, 我对上面的概念有了更细致的理解, 不再局限于文字描述, 直接上内存:) </br></p>
<blockquote>
<p>计算机接通电源后, 读取固化(比如烧录)到ROM芯片上的BIOS程序</p>
</blockquote>
<p>其实这句话暗含了一个复杂的过程, 如图: </br>
<img alt="bios" src="http://7xj431.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-26%20%E4%B8%8B%E5%8D%8811.23.44.png" /> </br>
计算机通过读取cs:ip寄存器中的地址找到程序执行的实际内存地址(实模式下段基址+段内偏移地址). 计算机启动时, cs:ip寄存器被强制初始化为f000:fff0, 对应实际的内存地址:0xffff0, 也就是bios的起始地址, 但是这段内存加载的程序是</p>
<div class="codehilite"><pre><span></span>jmpf 0xf000:e05b
</pre></div>


<p>:
所以跳转到 0xfe05b, 是的, 这才是bios程序真正的起始地址, 然后就是执行bios程序啦. </br>
但是，为什么要跳转呢? </br>
还是因为实模式, 实模式下(20位地址总线)最多可以访问1MB内存(2^20), 而bios的起始地址是0xffff0, 距离1MB的结束地址0xfffff只剩1个字节了, 自然放不下bios程序, 所以通过跳转来另辟蹊径. 至于为什么从0xffff0开始, 因为之前的内存有分配了:) </br>
实模式下的内存布局</br></p>
<p>| 起始 | 结束 | 大小 | 用途 |
| ---- | ---- | ---- | ---- |
| FFFF0 | FFFFF | 16B | BIOS的入口地址 |
| F0000 | FFFEF | 64KB-16B | 顶部的640KB字节 |
| C8000 | EFFFF | 160KB    | 映射硬件适配器的ROM或者内存映射式I/O |
| C0000 | C7FFF | 32KB     | 显示适配器BIOS |
| B8000 | BFFFF | 32KB     | 用于文本模式显示适配器 |
| B0000 | B7FFF | 32KB     | 用于黑白显示适配器 |
| A0000 | AFFFF | 64KB     | 用于彩色显示适配器 |
| 9FC00 | 9FFFF | 1KB      | EBDA扩展BIOS数据区|
| 7E00  | 9FBFF | 约608KB   | 可用区域 |
| 7C00  | 7DFF  | 512B     | MBR被BIOS加载到此处, 共512个字节|
| 500   | 7BFF  | 约30KB   | 可用区域 |
| 400   | 4FF   | 256B     | BIOS Data Area(BIOS数据区) |
| 000   | 3FF   | 1KB      | IVT中断向量表|</p>
</hr>

<blockquote>
<p>这时计算机读取该设备第一个扇区的512个字节, 如果最后两个字节是0x55和0xAA, 则可以启动。</p>
</blockquote>
<p>这里的读取还是bios读取, bios会检测0盘0道1扇区(CHS表示法)512字节的最后两个字节是否是魔数:0x55和0xaa来判断并加载MBR主引导程序到0x7c00处. 至于为什么是0x7c00, 历史原因😂 , 限于篇幅, 具体还是看书吧!</p>
<h2>神奇的16进制</h2>
<p>第2章概念不难理解, 难就难在各种内存大小和内存地址转换上, 比如上面的内存布局表. 推荐一篇文章:</p>
<ul>
<li><a href="http://www.i-programmer.info/babbages-bag/478-hexadecimal.html?start=1">hexadecimal</a></li>
</ul>
<p>还有就是编写MBR汇编代码时各种恶心的寄存器, </br></p>
<ul>
<li><a href="http://web.ics.purdue.edu/~jricha14/Interrupts/SREG.htm#Bit 7  -  I: Global Interrupt Enable">sreg</a></li>
</ul>
<h2>截图留念:)</h2>
<p><img alt="neo1218:)" src="http://7xj431.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-26%20%E4%B8%8B%E5%8D%888.22.41.png" /></p>
        <div id="disqus_thread"></div>
        <script>
        /**
        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//neo1218flask.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </body>
</html>
