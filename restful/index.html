<html>
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href=/static/css/main.css rel="stylesheet" type="text/css">
        <title>关于Restful API的个人理解</title>
    </head>
    <body>
        <h1>关于Restful API的个人理解</h1>

<h2>API</h2>

<p>当今web应用的主流架构是C/S架构,
即客户端和服务器端分离. API定义了客户端和服务器端开发的规范, 数据传输的格式.
有了API, 资源就可以从后端(服务器)数据库通过约定的传输形式(json,
xml)传递给客户端,
客户端可以通过相应的HTTP方法(GET、POST、DELETE、PUT、PATCH)对资源进行操作.
可以说API是衔接客户端和服务器端的桥梁.</p>

<h2>Restful的6个核心概念</h2>

<h3>Client-Server</h3>

<p>我上段说过, API是衔接Client和Server的桥梁,</p>

<div class="codehilite"><pre><span></span>________
|      |                    __________
|      |&lt;-----A--P--I------&gt;| client |
|server|&lt;-----A--P--I------&gt;|        |
|      |                    \--------/
|______|                    /_________\
</pre></div>

<p>这里的Client是客户端的统称, 它可以是浏览器(web应用), 手机(安卓APP),
也可以是服务器:), 是的, 服务器和服务器之间也可以通过API进行交互, 构建集群.</p>

<h3>Layered System</h3>

<p>API是可以分层的, http协议可以经过多层代理, API也是如此,
你可以在server和client之间加入中间件进行一些操作, 比如请求分发、请求过滤...</p>

<div class="codehilite"><pre><span></span>________
|      | &lt;-----A--P--I------&gt; __________
|      |    ____________      | client |
|server|    |  Layered |      |        |
|      |    |__________|      \--------/
|______| &lt;-----A--P--I------&gt; /_________\
</pre></div>

<p>你可以用中间件实现一个简单的路由系统, 比如你偏爱flask简洁的装饰器路由,
你可以实现这样的一个装饰器,
并作为中间件的形式在web开发中应用到别的web框架上.<br/>
当然, 坏处也出现了,
你无法通过http头信息判断向服务器发出请求的究竟是何种客户端,因为服务器只能"看见"中间件了.<br/>
通过中间件, 你可以实现负载均衡, 我之前说过中间件可以做请求分发,
如果一台服务器无法承载你的API系统, 那么你可以将API部署到多台服务器上,
结合服务器的并发能力设计中间件的请求分发, 就可以达到"均衡负载",
而且客户端不会感觉到这一切, 因为他们也只能看到中间件. <br/></p>

<h3>Cache</h3>

<p>缓存是web应用中很重要的一个环节, 可以依靠中间件做缓存(比如nginx代理服务器),
而客户端浏览器也会自动进行缓存.</p>

<h3>Stateless</h3>

<p>无状态是个有意思的概念, 所谓无状态,
就是http协议在每次会话中不会记录任何请求信息, 换句话说在每次http请求的过程中,
客户端都需要提供相同(且完全)的信息. 或许有人会问, 为什么不用cookie存储, 对不起,
API是支持多终端的, 而cookie仅限于浏览器. 那么服务器端session呢？session
可以是个选择, 但是对于多终端尤其是多服务器,
session的同步是一个特别麻烦的事情. 没有很好的存储选择, 只能遵守http的无状态.</p>

<h3>Uniform Interface</h3>

<p>API是接口, 谈到接口就要有接口设计, 一个好的接口设计可以被称道一辈子(比如Python
requests), restful API的接口设计也有一些规范:</p>

<ol>
<li>
<p><strong>api域名的根路径应该显示所有的API资源目录</strong></p>
<p>API:: https://api.example.com/</p>
<p>{
    'meta': {
        'version': 'v1',
        'author': 'neo1218'
    },
    'apis': {
        'users': https://api.example.com/users/,
        'posts': https://api.example.com/posts/,
    }
}</p>
</li>
<li>
<p><strong>每一个资源都应该有独特的URL</strong> <br/></p>
</li>
<li><strong>表现层状态转移</strong> <br/>
嗯, 这又是一个有意思的概念, 是restful名字的由来. 客户端不能直接存取资源,
客户端只能看到资源的表现层. 客户端不需要知道数据库表的字段和设计,
客户端知道的是json中的字段和格式. 所有客户端的操作都是对json的操作.</li>
<li><strong>Hypermedia</strong> <br/></li>
</ol>

<h3>Code-On-Demand</h3>

<p>Code-On-Demand,
就是服务器端可以按需通过API提供给客户端执行的代码。这一点在实际的API中应用的很少,
一个API系统通常是为了支持多种终端而设计的(浏览器, 手机),
后端面对的是多种客户端的差异, 所以Code-On-Demand并不具备实际价值.</p>

<h2>Restful API的设计</h2>

<h3>HTTPS</h3>

<p>Restful API 最好使用https协议。所谓https可以理解为安全的http协议，传统的http
协议是完全暴露在明文环境下的, 信息很容易被他人获取(不设防), 比如校园通的模拟
登录, 第三方可以劫持该次请求，解析http basic auth, 获取信息门户的用户名和密码,
当然对于含有用户系统的(用户数据库)的后端可以通过id加密进行验证和操作。<br/>
https协议, 则在http协议进行会话的过程中使用session key进行加密(对称加密),
而且session key本身采用公钥加密(非对称加密),
只要公钥和私钥构造的足够好, 以目前计算机的计算能力, 几乎无法破解.
用于生成session key的随机数以及用于加密session
key的公钥则是客户端和服务器端建立SSL/TLS协议中创建和发送的.<br/></p>

<h4>SSL/TLS</h4>

<p>SSL/TLS协议用于保证互联网通信的安全, 1994年网景公司设计了SSL(Secure Socket Layer)协议1.0.
SSL/TLS协议的核心是<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开密钥加密</a>,
公开密钥加密是一种非对称加密算法,
只有拥有同时生成的公钥和私钥才能对信息进行加密和解密,
比如加密的一方A可以向对方B索取公钥,
利用公钥进行加密的信息只能由B的私钥进行解密,别人即使获取了公钥和公钥加密的信息也无法破解.<br>
所以使用SSL/TLS协议, 客户端需要先向服务器端索取公钥, 不过这存在一个问题,
客户端如何确定这个公钥确实是这个服务器产生的, 而不是攻击者提供的公钥(如果这样,
攻击者的私钥就可以解密), 这就需要服务器将公钥放在数字证书中发送,
数字证书包含了服务器的相关信息, 以及服务器私钥生成的数字签名, 如此,
客户端就可以使用公钥解密数字签名并与服务器信息进行比对,从而确定公钥的来源.
<img alt="维基百科证书" src="http://7xj431.com1.z0.glb.clouddn.com/ll.png" /><br/>
理论上, 有了公钥就足够了, 但是公钥的生成太耗时,
所以每次客户端和服务器端会话采用快速的对称加密算法进行加密得到session key,
而仅对session key做公钥加密, 提高速度. <br/>
SSL/TLS协议的基本过程如下:</p>

<ol>
<li>客户端向服务器端索要并验证公钥</li>
<li>双方协商生成"对话密钥"</li>
<li>双方采用"对话密钥"进行加密通信</li>
</ol>

<p>1, 2两步统称为握手阶段. <br/>
在握手阶段中(此阶段是不加密的):</p>

<ol>
<li>
<p>客户端向服务器端发出加密通信请求, 客户端主要提供以下信息</p>
<ol>
<li>支持的SSL/TLS协议版本</li>
<li>一个客户端生成的随机数, 用于生成"对话密钥"</li>
<li>支持的加密算法</li>
<li>支持的压缩算法</li>
</ol>

<p></li>
<li></p>

<p>服务器端返回信息</p>

<ol>
<li>确认SSL/TLS协议版本</li>
<li>一个服务器生成的随机数, 用于生成"对话密钥"</li>
<li>确认使用的加密算法</li>
<li>服务器证书</li>
</ol>

<p></li>
<li></p>

<p>客户端收到回应后会验证服务器证书。如果证书没有问题, 客户端就会从证书中提取公钥.然后向服务器发送</p>

<ol>
<li>一个随机数, 用于服务器公钥加密, 防止被窃听</li>
<li>编码改变通知, 表示随后的信息都将用双方协定好的加密方法和密钥发送</li>
<li>握手结束通知</li>
</ol>

<p></li>
</ol></p>

<p>这里客户端生成的两个随机数和服务器生成的随机数一起用于session key的生成.</p>

<h3>域名</h3>

<p>根据API服务的规模和扩展性可以设计为2种形式</p>

<ol>
<li>https://api.foo.com : api作为主要服务,考虑到以后扩展, 专门分配一个子域名</li>
<li>https://foo.com/api/: 使用url前缀</li>
</ol>

<h3>版本</h3>

<p>版本号目前有2种风格</p>

<ol>
<li>版本号放在url中: https://api.example.com/v1/</li>
<li>版本号放在http头部</li>
</ol>

<h3>URI设计</h3>

<p>API通过URI标识资源, restful API的核心就是资源,
URI则是资源在服务器上的具体表示, 所以应该采用"名词+复数"的形式设计,且不包含动词,
动词由HTTP方法负责, 比如:</p>

<ol>
<li>标识用户资源: https://api.foo.com/v1/users/</li>
</ol>

<h3>HTTP动词</h3>

<p>HTTP动词负责对URI标识的资源进行CRUD操作, 常见的动词有以下5个</p>

<ol>
<li>GET: 从服务器获取资源或资源的集合</li>
<li>POST: 向服务器新建一个资源</li>
<li>PUT: 更新服务器上的一个资源(客户端需提供更新后完整的资源[json,xml格式])jo</li>
<li>PATCH: 更新服务器上的一个资源(客户端只需提供改变的属性)</li>
<li>DELETE: 删除服务器上的一个资源</li>
</ol>

<p>以上面用户资源为例</p>

<ol>
<li>GET https://api.foo.com/v1/users/ 获取用户资源集合</li>
<li>GET https://api.foo.com/v1/users/1/ 获取id为1的用户</li>
<li>POST https://api.foo.com/v1/users/ jsondata = {'id':2, 'username': 'neo1218', 'age': 20} 创建一个用户</li>
<li>PUT https://api.foo.com/v1/users/2/  jsondata = {'id':2, 'username': 'neo1218', 'age': 19} 更新该用户的年龄</li>
<li>PATCH: https://api.foo.com/v1/users/2/ jsondata = {'age': 20} 更新该用户的年龄</li>
<li>DELETE: https://api.foo.com/v1/users/2/ 删除这个用户</li>
</ol>

<h3>状态码</h3>

<p>客户端需要根据API返回的状态码判断此次请求是否成功, 以及失败的原因,
API的错误处理也应该严格遵循状态码, 常见状态码以及含义如下:</p>

<ul>
<li>200 OK: 服务器成功返回用户请求的数据</li>
<li>201 CREATED:  资源创建成功</li>
<li>202 Accepted: 表示一个请求已经进入后台排队, 主要用于异步任务</li>
<li>204 NO CONTENT: 用户删除数据成功</li>
<li>400 INVALID REQUEST 用户发出的请求有错误</li>
<li>401 Unauthorized: 用户没有权限</li>
<li>403 Forbidden: 用户有权限, 但是权限不足, 禁止访问</li>
<li>404 NOT FOUND: 资源不存在</li>
<li>406 Not Acceptable: 用户请求的格式不可得(比如用户请求xml格式, 但是服务器端只返回json格式)</li>
<li>410 Gone: 用户请求的资源被永久删除</li>
<li>500 INTERNAL SERVER ERROR: 服务器发生错误, 你的代码写错了</li>
</ul>

<h3>错误处理</h3>

<p>相比于传统的web应用返回html页面, API的错误设计也应该返回json格式, 比如</p>

<div class="codehilite"><pre><span></span>{
    &#39;message&#39;: &#39;not found&#39;,
    &#39;status&#39;: 404
}
</pre></div>

<h3>API返回结果</h3>

<p>还是以user为例</p>

<ol>
<li>
<p>返回单个资源实例: hash表结构</p>
<p>{
    'id': 2,
    'username': 'neo1218',
    'age': 20
}</p>
</li>
<li>
<p>返回资源集合: 数组结构</p>
<p>[
    {
        'id': 1,
        'username': 'zxc0328',
        'age': 23
    },
    {
        'id': 2,
        'username': 'neo1218',
        'age': 20
    },
    {...}
]</p>
</li>
<li>
<p>POST, DELETE, PUT, PATCH, 由于状态码可定, 为了避免冗余, 可以返回空hash<code>{}</code></p>
</li>
</ol>

<h3>Hypermedia</h3>

<p>客户端使用API获取资源和我们通过浏览器上网本质上都是一样的,
都是对服务器资源的获取和查找. 正如同网站上的链接将我们指向不同的资源,
API的设计也应该时可以索引的, 有层次的, 比如(以user为例):</p>

<div class="codehilite"><pre><span></span>{
    &#39;id&#39;: 2,
    &#39;username&#39;: &#39;neo1218&#39;,
    &#39;comments&#39;: &#39;https://api.foo.com/v1/users/2/comments/&#39;
}
</pre></div>

<p>这里id为2的用户评论以指向评论资源的链接表示, 既避免了显示信息过多,
又方便客户端索引查找.</p>

<h3>认证</h3>

<p>认证机制推荐使用http basic auth的token认证机制</p>

<h2>更多资源</h2>

<ul>
<li><a href="https://www.youtube.com/watch?v=pZYRC8IbCwk">视频: Is Your Resr API Resful</a></li>
</ul>

<h2>参考</h2>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解restful架构</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API设计指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li>
<li><a href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a></li>
<li><a href="https://www.youtube.com/watch?v=pZYRC8IbCwk">视频: Is Your Resr API Resful</a></li>
</ul>

<p><hr/>
<img alt="填坑" src="http://tva1.sinaimg.cn/crop.0.0.200.200.180/006i0pdHjw8ey3tztfv7cg305k05kmx4.gif" /></p>

        <div id="disqus_thread"></div>
        <script>
        /**
        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//neo1218flask.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </body>
</html>
